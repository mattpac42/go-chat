# ===============================================================================
# üöÄ REUSABLE GitLab CI/CD PIPELINE TEMPLATE
# Python/Flask Docker-based Deployment
# ===============================================================================
# DESCRIPTION:
#   Generic, production-ready CI/CD pipeline for Python/Flask applications.
#   Includes comprehensive linting, security scanning, testing, Docker build,
#   and deployment stages. Designed for home lab or production environments.
#
# CUSTOMIZATION:
#   1. Replace all {{PLACEHOLDER}} values with your project-specific values
#   2. Update security scanning tools/configs as needed
#   3. Adjust Docker/deployment settings for your infrastructure
#   4. Review and modify stage rules based on your workflow
#
# VERSION: 1.0.0
# LAST UPDATED: 2025-12-22
# ===============================================================================


# ===============================================================================
# üìã PLACEHOLDER REFERENCE TABLE
# ===============================================================================
# Use Find & Replace to customize this template for your project.
# All placeholders use {{DOUBLE_BRACES}} syntax for clarity.
#
# +---------------------------+------------------------------------------------+
# | PLACEHOLDER               | DESCRIPTION                                    |
# +---------------------------+------------------------------------------------+
# | {{APP_NAME}}              | Application name (e.g., "harvest", "dashboard")|
# | {{APP_DOMAIN}}            | Production domain (e.g., "app.example.com")    |
# | {{DEPLOY_PORT}}           | Host port for application (e.g., "4000")       |
# | {{CI_REGISTRY_IMAGE}}     | Full registry path                             |
# |                           | (e.g., "gitlab.yuki.lan:5050/project/app")     |
# | {{PYTHON_VERSION}}        | Python version (default: "3.12")               |
# +---------------------------+------------------------------------------------+
#
# EXAMPLE REPLACEMENT:
#   Find: {{APP_NAME}}
#   Replace with: my-flask-app
#
# TIP: Use your IDE's "Replace All" feature for quick customization.
# ===============================================================================


# ===============================================================================
# üîß PIPELINE VARIABLES
# ===============================================================================
# These variables control pipeline behavior and can be overridden in GitLab UI
# under Settings > CI/CD > Variables

variables:
  # -------------------------------------------------------------------------
  # Application Configuration
  # -------------------------------------------------------------------------
  # WHY: Centralizes app-specific values for easy maintenance
  APP_NAME: "{{APP_NAME}}"
  APP_DOMAIN: "{{APP_DOMAIN}}"
  DEPLOY_PORT: "{{DEPLOY_PORT}}"

  # -------------------------------------------------------------------------
  # Container Registry Configuration
  # -------------------------------------------------------------------------
  # WHY: Defines where Docker images are stored and pulled from
  # NOTE: GitLab provides CI_REGISTRY automatically, but home labs may need custom values
  CI_REGISTRY: "gitlab.yuki.lan:5050"
  CI_REGISTRY_IMAGE: "{{CI_REGISTRY_IMAGE}}"

  # -------------------------------------------------------------------------
  # Version Management
  # -------------------------------------------------------------------------
  # WHY: Tracks application version for tagging and release notes
  # NOTE: Create a VERSION file in your repo root with semantic version (e.g., "1.0.0")
  VERSION_FILE: "VERSION"

  # -------------------------------------------------------------------------
  # Python Version
  # -------------------------------------------------------------------------
  # WHY: Ensures consistent Python version across all pipeline stages
  PYTHON_VERSION: "{{PYTHON_VERSION}}"

  # -------------------------------------------------------------------------
  # Docker Configuration
  # -------------------------------------------------------------------------
  # WHY: Docker-in-Docker (DinD) configuration for building images in CI
  DOCKER_DRIVER: overlay2                  # Best performance for Docker-in-Docker
  DOCKER_TLS_CERTDIR: ""                   # Disabled - registry TLS handles security

  # -------------------------------------------------------------------------
  # Quick Deploy Toggle
  # -------------------------------------------------------------------------
  # WHY: Speeds up development by skipping heavy stages (lint, test, scan)
  # USAGE: Set to "false" for full pipeline, "true" for rapid iteration
  # WARNING: Never use QUICK_DEPLOY=true for production releases!
  QUICK_DEPLOY: "false"


# ===============================================================================
# üìä PIPELINE STAGES
# ===============================================================================
# Stages run sequentially in the order defined here.
# Jobs within a stage run in parallel.

stages:
  - prepare    # Build custom Docker-in-Docker image with CA certificates
  - lint       # Code quality and style checks (flake8, black, isort)
  - test       # Unit and integration tests
  - build      # Build Docker image and push to registry
  - scan       # Security vulnerability scanning (Trivy, bandit, safety)
  - release    # Validate build quality before deployment
  - deploy     # Deploy to production environment


# ===============================================================================
# üîÅ REUSABLE JOB TEMPLATES (YAML Anchors)
# ===============================================================================
# These templates define common job configurations that can be reused across jobs.
# YAML Anchors (&name) define templates, Aliases (*name) reference them.

# -------------------------------------------------------------------------
# Skip If Quick Deploy Template
# -------------------------------------------------------------------------
# PURPOSE: Allows skipping heavy stages during rapid development iteration
# USAGE: Add '<<: *skip_if_quick' to any job that should skip in quick mode
.skip_if_quick: &skip_if_quick
  rules:
    - if: $QUICK_DEPLOY == "true"
      when: never                         # Don't run this job in quick mode
    - when: on_success                    # Run normally otherwise

# -------------------------------------------------------------------------
# Home Lab Root CA Installation
# -------------------------------------------------------------------------
# PURPOSE: Installs custom CA certificate for home lab/self-signed registries
# WHY: Enables Docker to trust your internal GitLab registry's TLS certificate
# USAGE: Reference in before_script with: *install-gitlab-cert
#
# SETUP REQUIRED:
#   1. Export your Caddy/home lab root CA certificate:
#      $ base64 -i /path/to/root-ca.crt | pbcopy  # macOS
#      $ base64 -w 0 /path/to/root-ca.crt         # Linux
#   2. Add to GitLab Variables: Settings > CI/CD > Variables
#      Variable: LOCAL_CA_CERT
#      Value: <paste base64 output>
#      Type: Variable (not File)
#      Protected: Yes
#      Masked: No (too long to mask)
.install-gitlab-cert: &install-gitlab-cert
  - echo "Installing Home Lab Root CA for GitLab at $CI_REGISTRY"
  - |
    # Install CA certificates package based on OS
    if command -v apt-get >/dev/null 2>&1; then
      apt-get update && apt-get install -y ca-certificates curl
    elif command -v apk >/dev/null 2>&1; then
      apk add --no-cache ca-certificates curl
    fi
  - |
    # Install Home Lab Root CA if provided
    if [ -n "${LOCAL_CA_CERT:-}" ]; then
      echo "Installing Caddy Root CA from LOCAL_CA_CERT variable..."
      echo "$LOCAL_CA_CERT" | base64 -d > /tmp/home-lab-ca.crt

      # Update system CA trust store
      if command -v update-ca-certificates >/dev/null 2>&1; then
        mkdir -p /usr/local/share/ca-certificates/
        cp /tmp/home-lab-ca.crt /usr/local/share/ca-certificates/caddy-root-ca.crt
        update-ca-certificates
      fi

      # Configure Docker registry trust
      mkdir -p /etc/docker/certs.d/${CI_REGISTRY}
      cp /tmp/home-lab-ca.crt /etc/docker/certs.d/${CI_REGISTRY}/ca.crt

      echo "‚úÖ Caddy Root CA installed"
    else
      echo "‚ö†Ô∏è LOCAL_CA_CERT not set, skipping CA installation"
    fi

# -------------------------------------------------------------------------
# Default Docker Executor Configuration
# -------------------------------------------------------------------------
# PURPOSE: Standard Docker-in-Docker configuration for building images
# WHY: Provides consistent Docker environment across all build/scan jobs
# USAGE: Add 'extends: .docker-executor' to jobs that need Docker
.docker-executor:
  tags: ["docker"]                        # Uses GitLab Runner with docker executor
  image: docker:27                        # Official Docker CLI image
  services:
    - name: $CI_REGISTRY_IMAGE/docker-dind:27-with-cert
      alias: docker                       # Makes DinD available as 'docker' hostname
  before_script:
    # Wait for Docker daemon to become ready
    - |
      echo "Waiting for Docker daemon..."
      for i in $(seq 1 30); do
        if docker info >/dev/null 2>&1; then
          echo "‚úì Docker daemon ready"
          break
        fi
        if [ $i -eq 30 ]; then
          echo "‚úó Docker daemon failed to start"
          exit 1
        fi
        sleep 1
      done
    # Authenticate to container registry
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"


# ===============================================================================
# üèóÔ∏è PREPARE STAGE - Custom DinD Image with CA Certificate
# ===============================================================================
# PURPOSE: Builds a custom Docker-in-Docker image with your home lab CA pre-installed
# WHY: Avoids repeating CA installation in every job, speeds up pipeline
# WHEN: Only rebuilds when Dockerfile.dind changes or triggered manually

build_dind_image:
  tags: ["docker"]
  stage: prepare
  image: docker:27
  services:
    - name: $CI_REGISTRY_IMAGE/docker-dind:27-with-cert
      alias: docker
      variables:
        DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "Using custom DinD image with Caddy Root CA trust"
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - echo "Building custom dind image with Caddy Root CA"
    # Check if image already exists and skip if Dockerfile unchanged
    - |
      if docker pull $CI_REGISTRY_IMAGE/docker-dind:27-with-cert 2>/dev/null; then
        echo "Custom dind image already exists, checking if rebuild needed..."
        if [ -z "$(git diff HEAD~1 -- Dockerfile.dind 2>/dev/null)" ]; then
          echo "‚úÖ No changes to Dockerfile.dind, using existing image"
          exit 0
        fi
      fi
    - echo "Building new custom dind image..."
    # Build with CA certificate baked in
    - |
      docker build \
        --build-arg LOCAL_CA_CERT="$LOCAL_CA_CERT" \
        -f Dockerfile.dind \
        -t $CI_REGISTRY_IMAGE/docker-dind:27-with-cert \
        -t $CI_REGISTRY_IMAGE/docker-dind:latest \
        .
    - docker push $CI_REGISTRY_IMAGE/docker-dind:27-with-cert
    - docker push $CI_REGISTRY_IMAGE/docker-dind:latest
    - echo "‚úÖ Custom dind image built and pushed"
  rules:
    # Only rebuild when Dockerfile.dind changes
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - Dockerfile.dind
        - .gitlab-ci.yml
      when: on_success
    # Allow manual trigger for certificate rotation
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: true


# ===============================================================================
# üîç LINT STAGE - Code Quality & Style Checks
# ===============================================================================
# PURPOSE: Enforces code quality standards and consistent style
# WHY: Catches style issues early, maintains codebase consistency
# TOOLS: Ruff (replaces flake8, black, isort for better performance)

# NOTE: You can replace Ruff with individual tools if preferred:
#   - flake8 (PEP 8 compliance)
#   - black --check (code formatting)
#   - isort --check (import sorting)
#   - mypy (optional: type checking)

lint:
  <<: *skip_if_quick                      # Skip in quick deploy mode
  tags: ["docker"]
  stage: lint
  image: python:${PYTHON_VERSION}-slim
  script:
    - pip install ruff
    - echo "üîç Running code quality checks with Ruff"
    - ruff check . --fix --output-format=full
    - ruff check . --output-format=full
    - echo "‚úÖ Code quality checks passed"
  # ALTERNATIVE: Use separate tools instead of Ruff
  # script:
  #   - pip install flake8 black isort
  #   - echo "Running flake8 (PEP 8 compliance)..."
  #   - flake8 . --max-line-length=100 --exclude=venv,__pycache__
  #   - echo "Running black (formatting check)..."
  #   - black --check .
  #   - echo "Running isort (import sorting check)..."
  #   - isort --check-only .


# ===============================================================================
# üß™ TEST STAGE - Unit & Integration Tests
# ===============================================================================
# PURPOSE: Runs automated tests to verify code correctness
# WHY: Catches bugs before deployment, ensures feature requirements met
# FRAMEWORK: pytest (most popular Python testing framework)

test:
  <<: *skip_if_quick                      # Skip in quick deploy mode
  tags: ["docker"]
  stage: test
  image: python:${PYTHON_VERSION}-slim
  script:
    - pip install pytest pytest-cov       # pytest with coverage reporting
    - pip install -r requirements.txt     # Install app dependencies
    - echo "üß™ Running Python tests..."
    # Only run tests if test files exist
    - |
      if find . -name "test_*.py" -o -name "*_test.py" | grep -q .; then
        python -m pytest -v --cov=. --cov-report=term-missing
      else
        echo "No test files found, skipping tests"
      fi
  # Optional: Generate coverage reports as artifacts
  # artifacts:
  #   reports:
  #     coverage_report:
  #       coverage_format: cobertura
  #       path: coverage.xml
  #   paths:
  #     - htmlcov/
  #   expire_in: 7 days


# ===============================================================================
# üîí SECURITY SCAN STAGE - Dependency & Code Security Analysis
# ===============================================================================
# PURPOSE: Identifies security vulnerabilities in code and dependencies
# WHY: Prevents shipping known vulnerabilities to production
# TOOLS: bandit, safety, pip-audit, detect-secrets

# NOTE: This stage runs BEFORE building Docker image to catch issues early
# Container image scanning happens in the 'scan_image' job after build

security_scan:
  <<: *skip_if_quick                      # Skip in quick deploy mode
  tags: ["docker"]
  stage: test                             # Runs in parallel with unit tests
  image: python:${PYTHON_VERSION}-slim
  before_script:
    - pip install bandit safety pip-audit detect-secrets
    - pip install -r requirements.txt     # Required for some scanners
  script:
    # -----------------------------------------------------------------------
    # Bandit - Python code security scanner
    # -----------------------------------------------------------------------
    # WHY: Finds common security issues in Python code (SQL injection, etc.)
    - echo "üîí Running bandit security scan..."
    - bandit -r . -f json -o bandit-report.json || true
    - bandit -r . -f screen

    # -----------------------------------------------------------------------
    # Safety - Dependency vulnerability scanner
    # -----------------------------------------------------------------------
    # WHY: Checks Python packages against known vulnerability database
    - echo "üîí Running safety vulnerability scan..."
    - safety check --json > safety-report.json || true
    - safety check --full-report

    # -----------------------------------------------------------------------
    # pip-audit - Additional dependency scanner
    # -----------------------------------------------------------------------
    # WHY: Cross-references with PyPI advisory database
    - echo "üîí Running pip-audit..."
    - pip-audit --format=json > pip-audit-report.json || true
    - pip-audit

    # -----------------------------------------------------------------------
    # detect-secrets - Credential leak detection
    # -----------------------------------------------------------------------
    # WHY: Prevents accidental commit of passwords, API keys, tokens
    - echo "üîí Scanning for secrets in codebase..."
    - detect-secrets scan --all-files --force-use-all-plugins > .secrets.baseline || true
    - |
      if [ -s .secrets.baseline ]; then
        echo "‚ö†Ô∏è Potential secrets detected:"
        cat .secrets.baseline
      else
        echo "‚úÖ No secrets detected"
      fi
  artifacts:
    paths:
      - bandit-report.json
      - safety-report.json
      - pip-audit-report.json
      - .secrets.baseline
    expire_in: 30 days
    when: always                          # Save reports even if job fails
  allow_failure: true                     # Don't block pipeline on vulnerabilities


# ===============================================================================
# üê≥ BUILD STAGE - Docker Image Build & Push
# ===============================================================================
# PURPOSE: Builds production Docker image and pushes to registry
# WHY: Creates immutable, deployable artifact with version tracking
# OUTPUT: Multiple image tags for different use cases

build_image:
  extends: .docker-executor
  stage: build
  script:
    # -----------------------------------------------------------------------
    # Version Calculation
    # -----------------------------------------------------------------------
    # WHY: Creates unique version tag for each build for traceability
    - VERSION=$(cat $VERSION_FILE)
    - SHORT_SHA="${CI_COMMIT_SHORT_SHA}"
    - FULL_SHA="${CI_COMMIT_SHA}"
    - VERSION_TAG="${VERSION}-${SHORT_SHA}"

    - echo "Building version--${VERSION_TAG}"

    # -----------------------------------------------------------------------
    # Build Metadata Generation
    # -----------------------------------------------------------------------
    # WHY: Embeds build information in image for debugging and auditing
    - |
      cat > .buildinfo << EOF
      {
        "version": "$VERSION",
        "version_tag": "$VERSION_TAG",
        "git_commit": "$SHORT_SHA",
        "git_commit_full": "$FULL_SHA",
        "git_branch": "$CI_COMMIT_REF_NAME",
        "git_commit_time": "$CI_COMMIT_TIMESTAMP",
        "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "build_job": "$CI_JOB_ID",
        "pipeline": "$CI_PIPELINE_ID"
      }
      EOF

    # -----------------------------------------------------------------------
    # Docker Image Build
    # -----------------------------------------------------------------------
    # WHY: Build once, tag multiple times for efficiency
    - docker build -t temp-build:${CI_PIPELINE_ID} .

    # -----------------------------------------------------------------------
    # Image Tagging Strategy
    # -----------------------------------------------------------------------
    # WHY: Different tags serve different purposes:
    #   - VERSION_TAG: Unique immutable reference (e.g., "1.2.3-a1b2c3d")
    #   - sha-FULL_SHA: Git commit reference for exact reproducibility
    #   - VERSION: Semantic version (e.g., "1.2.3") - can be overwritten
    #   - latest: Always points to most recent build
    - docker tag temp-build:${CI_PIPELINE_ID} $CI_REGISTRY_IMAGE:${VERSION_TAG}
    - docker tag temp-build:${CI_PIPELINE_ID} $CI_REGISTRY_IMAGE:sha-${FULL_SHA}
    - docker tag temp-build:${CI_PIPELINE_ID} $CI_REGISTRY_IMAGE:${VERSION}
    - docker tag temp-build:${CI_PIPELINE_ID} $CI_REGISTRY_IMAGE:latest

    # -----------------------------------------------------------------------
    # Push to Registry
    # -----------------------------------------------------------------------
    - echo "Pushing tags--${VERSION_TAG}, sha-${FULL_SHA}, ${VERSION}, latest"
    - docker push $CI_REGISTRY_IMAGE:${VERSION_TAG}
    - docker push $CI_REGISTRY_IMAGE:sha-${FULL_SHA}
    - docker push $CI_REGISTRY_IMAGE:${VERSION}
    - docker push $CI_REGISTRY_IMAGE:latest

    # -----------------------------------------------------------------------
    # Export Build Information
    # -----------------------------------------------------------------------
    # WHY: Makes build info available to downstream jobs (scan, deploy)
    - IMAGE_DIGEST=$(docker inspect $CI_REGISTRY_IMAGE:${VERSION_TAG} --format='{{.Id}}')
    - echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> build.env
    - echo "DOCKER_IMAGE=$CI_REGISTRY_IMAGE:${VERSION_TAG}" >> build.env
    - echo "VERSION=$VERSION" >> build.env
    - echo "VERSION_TAG=$VERSION_TAG" >> build.env

    # Cleanup temporary tag
    - docker rmi temp-build:${CI_PIPELINE_ID}
  artifacts:
    reports:
      dotenv: build.env                   # Makes variables available to other jobs
    paths: ["build.env", ".buildinfo"]
    expire_in: 1 hour


# ===============================================================================
# üõ°Ô∏è SCAN STAGE - Container Image Vulnerability Scanning
# ===============================================================================
# PURPOSE: Scans final Docker image for OS and library vulnerabilities
# WHY: Ensures no known vulnerabilities in production container
# TOOL: Trivy (comprehensive container and dependency scanner)

scan_image:
  <<: *skip_if_quick                      # Skip in quick deploy mode
  tags: ["docker"]
  stage: scan
  image: docker:27
  services:
    - name: $CI_REGISTRY_IMAGE/docker-dind:27-with-cert
      alias: docker
  needs: ["build_image"]                  # Requires built image
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    # Install Trivy scanner
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    # -----------------------------------------------------------------------
    # Pull Built Image
    # -----------------------------------------------------------------------
    - echo "Pulling image for vulnerability scan--${DOCKER_IMAGE}"
    - docker pull $DOCKER_IMAGE

    # -----------------------------------------------------------------------
    # Trivy Vulnerability Scan
    # -----------------------------------------------------------------------
    # WHY: Scans OS packages, app dependencies, and config issues
    # SEVERITY: Only reports HIGH and CRITICAL (adjust as needed)
    - echo "Scanning image for vulnerabilities--${DOCKER_IMAGE}"
    - trivy image --severity HIGH,CRITICAL --format json -o trivy.json $DOCKER_IMAGE

    # -----------------------------------------------------------------------
    # Human-Readable Report
    # -----------------------------------------------------------------------
    - echo "Generating human-readable report"
    - trivy image --severity HIGH,CRITICAL $DOCKER_IMAGE

    # OPTIONAL: Fail build on HIGH/CRITICAL vulnerabilities
    # - trivy image --severity HIGH,CRITICAL --exit-code 1 $DOCKER_IMAGE
  artifacts:
    paths: ["trivy.json"]
    expire_in: 30 days
    when: always
  allow_failure: true                     # Don't block deployment on vulnerabilities


# ===============================================================================
# ‚úÖ RELEASE GATE - Pre-Deployment Validation
# ===============================================================================
# PURPOSE: Final quality check before allowing deployment
# WHY: Ensures only validated builds reach production
# CHECKS: Vulnerability scan results, build artifacts, deployment readiness

release_gate:
  tags: ["docker"]
  stage: release
  image: alpine:latest
  needs:
    - job: "build_image"
    - job: "scan_image"
      optional: true                      # Don't block if scan was skipped
  before_script:
    - apk add --no-cache jq               # JSON processor for parsing scan results
  script:
    # -----------------------------------------------------------------------
    # Quick Deploy Bypass
    # -----------------------------------------------------------------------
    # WHY: Skip security checks in development mode
    - |
      if [ "${QUICK_DEPLOY:-false}" = "true" ]; then
        echo "üöÄ QUICK DEPLOY MODE: Skipping security checks"
        echo "‚úÖ Quick release approved"
        exit 0
      fi

    # -----------------------------------------------------------------------
    # Vulnerability Assessment
    # -----------------------------------------------------------------------
    # WHY: Reviews scan results and decides if deployment should proceed
    - echo "Checking vulnerability scan results..."
    - |
      if [ -f "trivy.json" ]; then
        HIGH_CRIT_COUNT=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL" or .Severity=="HIGH")] | length' trivy.json)
        echo "Found ${HIGH_CRIT_COUNT} HIGH/CRITICAL vulnerabilities"

        if [ "$HIGH_CRIT_COUNT" -gt 0 ]; then
          echo "‚ö†Ô∏è HIGH/CRITICAL vulnerabilities found"
          jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL" or .Severity=="HIGH") | "‚Ä¢ \(.VulnerabilityID): \(.Severity) - \(.Title // .Description)"' trivy.json | head -20
          echo "Note: Continuing deployment (allow_failure: true)"
          # PRODUCTION: Change to 'exit 1' to block deployment
        else
          echo "‚úÖ No critical/high vulnerabilities found"
        fi
      else
        echo "‚ö†Ô∏è No scan results found, skipping vulnerability check"
      fi

    # -----------------------------------------------------------------------
    # Release Artifact Creation
    # -----------------------------------------------------------------------
    # WHY: Creates deployment manifest for audit trail
    - mkdir -p release
    - echo "$DOCKER_IMAGE" > release/image.txt
    - echo "$IMAGE_DIGEST" >> release/image.txt
    - echo "‚úÖ Release gate passed"
  artifacts:
    paths: ["release/"]
  rules:
    # Only run for main branch or tags
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG'
      when: on_success
    # Allow manual deployment from other branches
    - when: manual


# ===============================================================================
# üöÄ DEPLOY STAGE - Production Deployment
# ===============================================================================
# PURPOSE: Deploys validated Docker image to production environment
# WHY: Delivers features to users via automated, reliable deployment
# METHOD: SSH + docker-compose deployment to target host

deploy_to_platform:
  tags: ["docker"]
  stage: deploy
  image: alpine:latest
  needs:
    - job: "build_image"
      artifacts: true                     # Requires build.env file
    - job: "release_gate"
  before_script:
    # -----------------------------------------------------------------------
    # SSH Configuration
    # -----------------------------------------------------------------------
    # WHY: Establishes secure connection to deployment target
    # SETUP REQUIRED:
    #   1. Generate SSH key: ssh-keygen -t ed25519 -C "gitlab-ci-deploy"
    #   2. Add public key to target host: ~/.ssh/authorized_keys
    #   3. Add private key to GitLab Variables:
    #      Name: DEPLOY_SSH_KEY
    #      Type: File
    #      Value: <private key contents>
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - cp "$DEPLOY_SSH_KEY" ~/.ssh/deploy_key
    - chmod 600 ~/.ssh/deploy_key
    - echo "Host *" > ~/.ssh/config
    - echo "  StrictHostKeyChecking no" >> ~/.ssh/config
    - echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
    - chmod 600 ~/.ssh/config
  script:
    # -----------------------------------------------------------------------
    # Deployment Execution
    # -----------------------------------------------------------------------
    # REQUIRED GITLAB VARIABLES:
    #   - DEPLOY_HOST: Target server IP/hostname (e.g., "192.168.0.200")
    #   - DEPLOY_USER: SSH user on target (e.g., "deployer")
    #   - DEPLOY_PATH: App directory on target (e.g., "/opt/{{APP_NAME}}")
    #   - DEPLOY_SSH_KEY: SSH private key (File type)
    - echo "Deploying to ${DEPLOY_HOST} as ${DEPLOY_USER}"
    - echo "Image--${DOCKER_IMAGE}"

    # Copy docker-compose.yml to target host
    - scp -i ~/.ssh/deploy_key -o IdentitiesOnly=yes docker-compose.yml ${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_PATH}/

    # Deploy container via docker-compose
    # NOTE: GitLab's YAML parser requires '--' instead of ':' in echo statements
    - ssh -i ~/.ssh/deploy_key -o IdentitiesOnly=yes ${DEPLOY_USER}@${DEPLOY_HOST} "cd ${DEPLOY_PATH} && export DOCKER_IMAGE='${DOCKER_IMAGE}' && export GIT_COMMIT_SHA='${CI_COMMIT_SHORT_SHA}' && export GIT_BRANCH='${CI_COMMIT_REF_NAME}' && export GIT_COMMIT_TIME='${CI_COMMIT_TIMESTAMP}' && echo '${CI_JOB_TOKEN}' | docker login -u gitlab-ci-token --password-stdin '${CI_REGISTRY}' && docker-compose pull && docker-compose up -d && sleep 5 && docker-compose ps"

    # -----------------------------------------------------------------------
    # Health Check
    # -----------------------------------------------------------------------
    # WHY: Verifies application is running and responding
    - echo "Running health check"
    - sleep 3
    - ssh -i ~/.ssh/deploy_key -o IdentitiesOnly=yes ${DEPLOY_USER}@${DEPLOY_HOST} "curl -f http://localhost:${DEPLOY_PORT}/ || exit 1"
    - echo "Application is healthy"
    - echo "Public URL--https://${APP_DOMAIN}"
  environment:
    name: production
    url: https://$APP_DOMAIN              # GitLab tracks deployment history
  rules:
    # Auto-deploy on main branch
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    # Allow manual deployment otherwise
    - when: manual


# ===============================================================================
# üìö ADDITIONAL NOTES & CUSTOMIZATION TIPS
# ===============================================================================
#
# DOCKER-COMPOSE.YML SETUP:
#   Create a docker-compose.yml in your repo root. Example:
#
#   services:
#     {{APP_NAME}}:
#       image: ${DOCKER_IMAGE}
#       container_name: {{APP_NAME}}
#       restart: unless-stopped
#       ports:
#         - "{{DEPLOY_PORT}}:5000"
#       environment:
#         - FLASK_ENV=production
#       labels:
#         - "traefik.enable=true"
#         - "traefik.http.routers.{{APP_NAME}}.rule=Host(`{{APP_DOMAIN}}`)"
#
# DOCKERFILE SETUP:
#   Create a Dockerfile in your repo root. Example:
#
#   FROM python:{{PYTHON_VERSION}}-slim
#   WORKDIR /app
#   COPY requirements.txt .
#   RUN pip install --no-cache-dir -r requirements.txt
#   COPY . .
#   CMD ["python", "app.py"]
#
# VERSION FILE SETUP:
#   Create a VERSION file in your repo root with semantic version:
#   $ echo "1.0.0" > VERSION
#
# DOCKERFILE.DIND SETUP (Optional - for home lab CA):
#   Create Dockerfile.dind in your repo root:
#
#   FROM docker:27-dind
#   ARG LOCAL_CA_CERT
#   RUN apk add --no-cache ca-certificates && \
#       echo "$LOCAL_CA_CERT" | base64 -d > /usr/local/share/ca-certificates/caddy-root-ca.crt && \
#       update-ca-certificates
#
# GITLAB RUNNER SETUP:
#   Ensure your GitLab Runner has the 'docker' tag and privileged mode enabled:
#   $ sudo gitlab-runner register --tag-list docker --executor docker --docker-privileged
#
# SECURITY BEST PRACTICES:
#   - Never commit secrets to git (use GitLab Variables)
#   - Use Protected Variables for production credentials
#   - Enable container registry authentication
#   - Review security scan results regularly
#   - Keep base images updated
#
# TROUBLESHOOTING:
#   - Pipeline fails with "mapping values are not allowed": Check for colons in echo statements
#   - Docker login fails: Verify LOCAL_CA_CERT is set correctly
#   - Deployment fails: Check DEPLOY_* variables and SSH key permissions
#   - Tests not found: Ensure test files use test_*.py naming convention
#
# ===============================================================================
